\documentclass[a4paper,12pt]{article}
\usepackage{fancyhdr}
\usepackage{fancyheadings}
\usepackage[english]{babel}
\usepackage{german}

\usepackage[utf8]{inputenc}
%\usepackage[latin1]{inputenc}
\usepackage[active]{srcltx}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{listings}
\usepackage{struktex}
\usepackage{hyperref}
\usepackage[breakable]{tcolorbox}
\usepackage[a4paper, left=2cm, right=2cm, top=2cm]{geometry}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{dsfont}
\usepackage{multicol}
\usepackage{pgfplots}
\usetikzlibrary{trees}
\pgfplotsset{compat=newest}
\usetikzlibrary{shapes.geometric}


\newcommand{\contradiction}{{\hbox{%
			\setbox0=\hbox{$\mkern-3mu\times\mkern-3mu$}%
			\setbox1=\hbox to0pt{\hss$\times$\hss}%
			\copy0\raisebox{0.5\wd0}{\copy1}\raisebox{-0.5\wd0}{\box1}\box0
}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Fach}{Grenzwerte}
\newcommand{\Semester}{SoSe 21}
\newcommand{\Uebungsblatt}{Lexicographic Cotree Factorization} 
\newcommand{\nl}{\\[0,20cm]}
\newcommand{\lnl}{\\[0,30cm]}
\newcommand{\xlnl}{\\[0,75cm]}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\setlength{\parindent}{0em}
\topmargin -2.0cm
\oddsidemargin 0cm
\evensidemargin 0cm
\setlength{\textheight}{9.6in}
\setlength{\textwidth}{6.9in}
\addtolength{\hoffset}{-22pt}


\newcommand{\limes}[2]{
	\lim\limits_{x\rightarrow #1}\quad  #2
}
\newcommand{\limesh}[1]{
	\lim\limits_{h\rightarrow 0}\quad  #1
}
\newcommand{\limesr}[2]{
	\lim\limits_{\underset{x > #1}{x\rightarrow #1}}\quad  #2
}
\newcommand{\limesl}[2]{
	\lim\limits_{\underset{x < #1}{x\rightarrow #1}}\quad  #2
}
\newcommand{\Aufgabe}[2]{
	{
		\vspace*{0.3cm}
		\begin{tcolorbox}[breakable,colback=yellow!0,colframe=black!65!black,title=\textbf{Aufgabe #1:},width=\linewidth ]
			{#2}
		\end{tcolorbox}
		
		
	}
}
\newcommand{\Hinweis}[1]{
	\vspace*{0.3cm}
	\begin{tcolorbox}[breakable,colback=yellow!10,colframe=yellow!65!black,title=\textbf{Hinweis:},width=\linewidth ]
		{#1}
	\end{tcolorbox}
}
\newcommand{\SHA}[1]{
	\vspace*{0.1cm}
	\begin{tcolorbox}[breakable,colback=blue!5,colframe=blue!65!black,title=\textbf{Richtiger SHA256 Hash:},width=\linewidth ]
		{\texttt{{#1}}}
	\end{tcolorbox}
}
\newcommand{\Beispiel}[1]{
	\vspace*{0.2cm}
	\begin{tcolorbox}[breakable,colback=yellow!0,colframe=green!65!black,title=\textbf{Beispiel:},width=\linewidth ]
		{#1}
	\end{tcolorbox}
}
\newcommand{\p}[2]{\pi_{#2}^{(#1)}}
\newcommand{\eing}[1]{\begin{enumerate}[\quad]
		\item #1
\end{enumerate}}

\newcommand{\abc}[1]{
	\begin{enumerate}[(a)]
		#1
	\end{enumerate}
}

\newcommand{\integral}[4]{\int\limits_{#1}^{#2} {#3} {\quad d #4}}
\newcommand{\summe}[3]{\sum\limits_{#1}^{#2} #3}
\begin{document}
	\thispagestyle{fancy}
	\pagestyle{fancy}
	\begin{center}
		\LARGE \sf \textbf{ \Uebungsblatt{}}
	\end{center}
	\vspace*{0.1cm}
	\tableofcontents
	\newpage
	\thispagestyle{fancy}
	\section{Theoretical Concept}
	\subsection{Tree}
	A tree $T$ is a tuple $(r,\mathcal{C})$ with $r$ as Root and $\mathcal{C}$ called childs, a set of trees. $T$ itself may not be in $\mathcal{C}$, neither some child of any node of $T$. Where a node is a Tree to find in $T$.  \\
	A tree $T$ will be called leaf if $T=(r,\emptyset)$
	\subsection{Lexicographic Product}
	Denote the Cotree of a Cograph $\,C$ as $T(C)$\\
	Let $C_1$ be a Cograph. $C_1$ is Product of two other Cographs $\,P_1$,$P_2\,$ iff  it is Cotree-Isomorphic to \\$T(P_1)\vartriangleleft T(P_2).$\\
	In other Words there exists a cotree, representing the identical cograph of the form:
		\begin{center}
		\begin{tikzpicture}[
			level distance=1.8cm,
			sibling distance=3.3cm, 
			level 2/.style={sibling distance =2cm},
			triangle/.style={isosceles triangle,draw,shape border rotate=90, dashed, minimum height=10mm, minimum width=15mm, inner sep=0},
			]
			\node[circle,draw] {$$}
			child{node[]{$\cdot^{\cdot^\cdot}$} 
				child{node[]{}
					child{node[triangle] {$T(P_2)$}
					}
				}
			child{node[]{$\cdots$} edge from parent [draw=none] child{node[triangle] {$T(P_2)$}}}
				child{node[]{}
					child{node[triangle] {$T(P_2)$}}
					}
				}
			child{node[]{$\cdots\cdots $} edge from parent [draw=none]}
			child{node[]{$\cdot_{\cdot_\cdot}$} 
				child{node[]{}
					child{node[triangle] {$T(P_2)$}
					}
				}
				child{node[]{$\cdots$} edge from parent [draw=none] child{node[triangle] {$T(P_2)$}}}
				child{node[]{}
					child{node[triangle] {$T(P_2)$}}
				}
			};
			
		\end{tikzpicture}
	\end{center}
	Where if one would remove every subtree $T(P_2)$ one would get $T(P_1)$.\\
	$T(P_1)\vartriangleleft T(P_2)$ just means attach $T(P_2)$ where a leaf in $T(P_1)$ is.\\
	It means as well that there are some problematic structures to deal with.
	like:\\
	
	
	\subsection{Balancing Cotrees}
	\subsection{Treedepth}
	Let $T$ be a Tree. Its depth $\,d(T)\,$ will be inductively bottom-up defined as follows:
	\begin{itemize}
		\item $T$ is leaf: \[d(T)=0\]
		\item $T$ isn't a leaf,\, $C_1,...,C_n$ the children of $T$: \[d(T)= max(d(C_1)+1,...,d(C_n)+1)\]
	\end{itemize}
	\vspace{0.5cm}
	The depth of a node $N$ with children $\, C_1,...,C_n$ said to be unambiguous iff
	\[d(N) = d(C_1)+1= ...=d(C_n)+1\]
	and the children of $N$ have unambiguous depth.
	
	\subsection{levels in a tree}
	The level of a node in  a tree is the distance from that node to the root of the tree.\\
	Let $T=(r,\mathcal{C})$ be a Tree, the level of a node in $T$ will be inductively top-down defined as follows:
	\begin{itemize}
		\item $l(T)=0$\\
		\item Let $P=(r_P,\mathcal{C}_P)$ be a labeled node. \[\forall C\in\mathcal{C}_P\quad l(C)= l(P) + 1\]
	\end{itemize}
	\subsection{Labeling}
	A Labeling for Trees gives every node of the tree a equivalence class with an order between them. Two of them be synonymous if they have the same equivalence classes and there exists an order isomorphism between their equivalence classes.
	\subsection{Connection of depth and level}
	Depth and Level are two non synonymous methods for labeling nodes in trees.\\
	But if the tree has unambiguous depth then the two labelings are indeed synonymous with inverse equivalence class ordering.
	\\\\
	 \underline{Proof by Induction:} Let $T=(r,\mathcal{C})$ be a Tree with unambiguous depth and $d(T)=n$\\
	 \begin{itemize}
	 	\item \underline{Base Case:}\\
	 		For $n=0\quad$ $T$ is a leaf $\implies$ both labelings are synonymous
	 		\[l_T^{(max)}-l_T(T)=0-0=0=d(T)\]
	 		with $l_T^{(max)}$ the number of levels of the tree $T$
	 	\item \underline{Induction Hypothesis:}\\
	 		Let the labelings be synonymous for trees $T$ with unambiguous depth of $n$.
	 		$N$ node of $T$ and with order isomorphism:
	 		\[l_T^{(max)}-l_T(N)=d(N)\]
	 		with $l_T^{(max)}$ the number of levels of the tree $T$
	 	\item \underline{Induction Step:}\\
	 		Let $T=(r,\mathcal{C})$ be a tree of unambiguous depth\\
	 		$\qquad\implies $ all $C\in\mathcal{C}$ are of unambigous depth.\\
	 		For every node $N$ of $C\in\mathcal{C}:$\[ l_T(N)=l_C(N)+1\] because every child of $T$ is on level 1 and itself is unambiguous.\\
	 		With that let $N$ be node of child $C\in\mathcal{C}$:
	 		\begin{align}
	 			l_T^{(max)}-l_T(N)&=l_T^{(max)}-(l_C(N) + 1)=l_C^{(max)} + 1 -(l_C(N) + 1)\\
	 			&= l_C^{(max)}-l_C(N) \overset{IH}{=} d(N)
	 		\end{align}
 			And for $T$: $d(T)=l_T^{(max)} - l_T(T)=l_T^{(max)}$\\
	 		with $l_T^{(max)}$ the number of levels of the tree $T$\\
	 		$\implies$ the two labelings are synonymous, because the order isomorphy is continued  (see (1)).\qed
	 \end{itemize}
	 \underline{Example:}\\
	 \begin{center}
	 	\begin{tikzpicture}[
	 		level distance=2cm,
	 		sibling distance=3cm, 
	 		level 2/.style={sibling distance =3cm},
	 		triangle/.style={isosceles triangle,draw,shape border rotate=90, dashed, minimum height=10mm, minimum width=15mm, inner sep=0},
	 		]
	 		\node[circle] {$0_{d=2}^{l=0}$}
	 		child{node[circle]{$1_{d=1}^{l=1}$} 
	 			child{node[circle]{$0_{d=0}^{l=2}$}}
	 			child{node[circle]{$0_{d=0}^{l=2}$}} }
	 		child{node[circle]{$1_{d=1}^{l=1}$} 
	 			child{node[circle]{$0_{d=0}^{l=2}$}} }
	 		child{node[circle]{$1_{d=1}^{l=1}$} 
	 			child{node[circle]{$0_{d=0}^{l=2}$}} };
	 	\end{tikzpicture}
	 \end{center}
	\subsection{Balancing}
	Because we may alter Cotrees in certain ways to leave them Cotree-Isomorphic to itself, e.g. it represents the same Cograph, we could use that to simplify our problem.\\
	One way to do so is balancing the tree, that its depth will be unambiguos.
	\\The Process starts inductively from the leafs, in other words from every node of the tree with depth equal to $0$.\\\\
	Induction for $d(T)=n$
	\begin{itemize}
		\item \underline{Base Case:}
			\[n=0 \,\implies \, \text{depth is unambiguous because there are no children}\]
		\item \underline{Induction Hypothesis:}\\
			For every child of $T$: $C_1,...,C_m$ the depth is unambiguous.
		\item \underline{Induction Step:}\\
		Let $T=(r,\mathcal{C})$ be a tree with $d(T) = n + 1$\\
		$\implies \,\forall C \in \mathcal{C}:\quad d(C)\leq n\qquad $ as well as $C$'s depth is unambiguous\\
		let $d_{min} = min\left(\{d(C)\, \vert \, C\in\mathcal{C}\}\right)$\\
		Now disconnect every child and attach a chain of nodes each with the same label as $r$. The length of the chain said to be $n - d_{min}$.\\
		Let $N_1,...,N_\delta$ be its nodes, counted from bottom to top. And let $N_0$ be $r$\\
		Now for every disconnected child $C$ attach it to the chain on node:
		\[N_{n - d(C)}\]
		Now $N_0,N_1,...,N_{n-d_{min}}$ have unambiguous depth.\\
		Node $N_{n-d_{min}}$ has unambiguous depth because all its childs are of depth $d_{min}$.\\
		If $N_{n-d_{min} - k }$ has unambiguous depth so has $N_{n- d_{min} - k - 1}$, because the depth of every attached child is $d_{min} + k$ as well as for the child node $N_{n-d_{min} - k}$. Every child of $N_{n- d_{min} - k - 1}$ has unambiguous depth. \\\qed
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[
			level distance=1.8cm,
			sibling distance=3cm, 
			level 2/.style={sibling distance =2cm},
			triangle/.style={isosceles triangle,draw,shape border rotate=90, dashed, minimum height=10mm, minimum width=15mm, inner sep=0},
			]
			\node[circle] {$r$}
			child{node[] {$d(C_1)=n$}child{node[triangle]{$C_1$} }}
			child{node[] {$d(C_2)=n-1$} child{node[triangle]{$C_2$}  }}
			child{node[] {$\mathbf{\cdot} \quad \mathbf{\cdot}  \quad \mathbf{\cdot} $} child{node[]{$\mathbf{\cdot}  \quad \mathbf{\cdot}  \quad \mathbf{\cdot} $}edge from parent [draw=none] }edge from parent [draw=none]}
			child{node[] {$d(C_m)=n-m+1$} child{node[triangle]{$C_m$} }};
		\end{tikzpicture}
		\\$\Downarrow$\\
		\begin{tikzpicture}[
			level distance=1.8cm,
			sibling distance=5cm, 
			level 2/.style={sibling distance =4cm},
			triangle/.style={isosceles triangle,draw,shape border rotate=90, dashed, minimum height=10mm, minimum width=15mm, inner sep=0},
			]
			\node[circle] {$N_0$}
			child{node[] {$N_1$}	
				child{node[] {$N_2$}
					child{node[] {$\,\,\,\,\,\cdot^{\cdot^{\cdot}}$} 
						child{node[] {$N_{m-1}$}
							child{node[] {$d(C_m)=n-m+1$} child{node[triangle]{$C_m$} }}
						}
					}
				child{node[] {$d(C_3)=n-2$} child{node[triangle]{$C_3$}  }} 
				}
			child{node[] {$d(C_2)=n-1$} child{node[triangle]{$C_2$}  }}
			}
			child{node[] {$d(C_1)=n$}child{node[triangle]{$C_1$} }};
			
		\end{tikzpicture}
	\end{center}
	With this method we have got a way for ensuring that level-labeling and depth labeling are indeed synonymous, providing us an easy way to modify the AHU-Algorithm after our needs.
	\subsection{Properties for the lexicographical Product of Cographs}
		\subsubsection{Minimal Cotree}
		Let $T=(r,\mathcal{C})$ be a cotree. $T$ said to be minimal if for every path in $T$ the sequence of label is always an alternating one.\\
		\[\text{cotree }\, T=(r,\mathcal{C}) \,\text{ is minimal }\, \Longleftrightarrow \forall (r_C,\mathcal{C}_C)=C\in\mathcal{C}:\quad C \,\text{ is minimal and }\, r_C \not = r \]
		I will denote the minimal cotree of $T$ with $T_{min}$
		
		\subsubsection{Relevance of Depth for finding the isomorphic subtrees}
			If we want to find a factor of some cograph $C$ with minimal cotree $T(C)_{min}$, we will be searching for a cotree isomorphic subtree, which root is located at depth $d_f$. In particular every node with depth $d_f$ is the root of such a subtree iff the cograf of such subtree is a factor of $C$.\\
			\underline{Proof:}
			
	\subsection{Find Isomorph Trees with AHU}
	\section{Practical Improvements}
	\section{Algorithm}
		\begin{tikzpicture}[
		sibling distance=5cm, 
		level 2/.style={sibling distance =2cm},
		triangle/.style={isosceles triangle,draw,shape border rotate=90, dashed, minimum height=10mm, minimum width=15mm, inner sep=0},
		]
		\node[circle] {0}
		child{node[circle]{1} 
			child{node[triangle]{T1}} };
	\end{tikzpicture}
\end{document} 